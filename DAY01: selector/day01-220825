## CSS란

- CSS (Cascading Style Sheet)
  - 엑셀 (Spread Sheet), 구글 시트 (Google Sheet)
  - Sheet > 데이터가 나열된, 열거된 공간
  - Style Sheet > 스타일이 나열된 공간
- 논리적인 결과물(ex.a가 있다면 b를 실행한다)을 만들어낼 수 있는 것은 아님
- Cascading > 폭포
  - Cascading이라는 특성을 지닌 스타일 시트 (= CSS)
- CSS 1.0 > 2.1 > 2.2 > 3.0 > 4.0
  - CSS Version은 그렇게 의미가 있지는 않음
- 특정한 스타일에 대한 표준이 만들어지고, 그 표준을 관리
- CSS Grid Layout (모듈 단위로 관리가 되고 있다)

## 셀렉터 101 (선택자)

- CSS는 스타일의 나열
- 스타일을 어디에 적용할지? > 셀렉터(Selector)

```css
/* 요소 셀렉터 - 요소 이름을 작성하면 됨*/
/* 요소 셀렉터의 단점&장점 
  1. 해당 이름의 요소에는 모두 스타일이 적용 
  2. 요소이름을 바꾸면 적용되지 않음 */
article {
}
h1 {
}
p {
}
```

```css
/* 클래스 셀렉터 -  특정한 클래스명을 가진 요소에 스타일을 부여 */
/* 숫자 또는 특수문자로 시작하면 안됨 */
/* 클래스명은 기본적으로 중첩이 가능 ex.<div class="box area"></div> */
/* 단위단위로 쪼개서 사용 가능, 스타일 분리와 확장성 고려에 따라 좋은 서비스를 만들 수 있다 */
```

```css
/* 클래스 셀렉터 -  특정한 클래스명을 가진 요소에 스타일을 부여 */
/* 숫자 또는 특수문자로 시작하면 안됨 */
.box {
}
.area {
}
```

```css
/* 속성 셀렉터 */
div[lang:ko] {
}
```

## 콤비네이터 101 (결합자)

- Selector만으로 못하는 것들을 할 수 있다
- 특정한 조건에 충족했을 떄에만, 자식 요소나 형제 요소를 제어하고 싶을 떄 사용
- 콤비네이터는 형제 요소들끼리만 적용 (부모는 해당 안됨)

```css
/* 특정한 요소의 자손 요소에 스타일을 주고 싶은 경우 */
/* 자손 콤비네이터 */
/* 공백 문자 */
/* {조상 요소} {자손 요소} */
/* 자식 요소에 관계 없이, 자손 요소 중 해당 요소가 있다면 적용 */
div h1 {
}
div p {
}
.area h1 {
}
.area .title {
}

/* 특정한 요소의 자식 요소에 스타일을 주고 싶은 경우 */
/* 자식 콤비네이터 */
/* '>' 사용 */
/*  {부모 요소} > {자식 요소} */
div > h1 {
}
.box > .title {
}
.main-menu > li {
}
```

```css
/* 특정한 요소의 형제 요소에 스타일ㅇ르 주고 싶은 경우 */
/* 형제sibling 콤비네이터 - 특정ㅎ산 요소의 형제이기만 하면 된다 */
/* ~ 사용 */
/* h1 요소의 형제 요소인 p 요소 전체에 스타일을 주고 싶을 때 */
h1 ~ p {
}

/* 인접 형제 콤비네이터 - 특정한 요소의 형제인데, 해당 요소에 바로 붙어있는 형제 요소 */
/* h1 요소에 바로 붙어있는 형제 요소인 p 요소에게만 스타일을 주고 싶을 때 */
h1 + p {
}
/* 많이 쓰이는 경우 - li 요소에 바로 붙어있는 형제 요소인 li 요소에게만 스타일 
첫째는 형제는 없으므로(가질 수 없으므로) 그 뒤부터 적용되는 효과*/
li + li {
  border-top: 1px solid #eee;
}
```

```css
/* 콤비네이터 - 이렇게도 작성할 수 있다 */
/* 이론상 조합에 제한이 없다 */
/* 복잡도가 높을 수록 관리 포인트가 많아지고 힘들어진다(유지보수에 어려움) */
/* 4 중첩은 안넘어가는 게 좋다. 컴포넌트로 넘기거나 하는 방법으로 */
.box > div > h1 + p {
}
.box ~ .box > h1 {
}

/* 셀렉터의 조합 */
div.box {
}
.box.area {
}
.button.on {
} /* variants */
.button.off {
} /* variants */
```

## 가상 셀렉터, 가상 요소

- 가상 (psuedo, 의사)
- 코드상으로 개념적으로 존재하는 것을, 가상
  - ex. 특정요소에 마우스를 올린 '상태'
  - 요소로 완전히 존재하는 것은 아니지만 개념적으로 존재하는 것들

```css
/* 마우스를 올린 상태 */
a:hover {
} /* hover: 터치 스크린에서는 한 번 클릭한 상태 */
a:hover ~ div {
} /* div까지 좌르륵 hover */

/* 마우스를 클릭한 상태, 요소가 활성화된 상태 */
a:active {
}

/* 특정한 링크를 이미 사용한 상태, 이미 방문한 사이트 */
a:visited {
}

/* 특정한 요소에 포커스가 간 상태 */
a:focus {
}

- 가상 요소
- 어떤 스타일을 넣기 위해서 요소를 추가해야 하는데, 이 요소가 의미론적으로 필요는 없지만 스타일을 위해 넣어야 하는 경우
  - ex. icon
- html이 존재하는 것처럼 가상으로 요소를 추가
```

```css
/* ::before, ::after */
/* 가상 요소 셀렉터는 모두 '::'를 사용*/
/* 'content' 속성이 필수값 */
/* 별도로 display 속성을 저장하지 않았다면, text로 취급 */
/* 복사 시 가상 요소 콘텐츠는 복사 범위에 해당 안됨 ex. content: '*'의 * */
/* 스타일적으로는 필요하나, 의미론적으로는 필요 없을 때 * */
div {
}
div::before {
} /* div 요소의 앞편 */
div::after {
} /* div 요소의 앞편 */
```

## Cascading

- 스타일이 중복되거나, 여러 스타일을 한 요소에 적용했을 때 어떤 걸 적용할지
- 캐스케이딩의 조건

  - 스타일이 어느 위치에 존재하는지 (같은 특정성이라면 뒤쪽에 존재하는 게 적용됨)
  - 특정성 계산 알고리즘 (셀렉터 하나당 1점)
    - 셀렉터 중 id 셀렉터의 갯수를 센다 (=a)
    - 셀렉터 중 클래스 셀렉터, 속성 셀렉터, 의사 클래스의 갯수를 센다 (=b)
    - 셀렉터 중 타입 셀렉터와 의사 요소의 갯수를 센다 (=c)
    - 전역 셀렉터는 무시한다.
    - { a b c } 순으로 숫자를 나열
    - 특정성의 숫자가 높을 수록 반영된다
  - !important 키워드 (안 쓰는 게 좋다)

  ```css
  div {
    color: red;
  }
  #box {
  } /* a=1, 특정성: 100*/
  .box {
  } /* b=1, 특정성: 010 */
  .area {
  } /* b=1, 특정성: 010 */
  .box .area {
  } /* b=2, 특정성: 020 */
  .box.area.container {
  } /* b=3,, 특정성: 030 */
  div {
  } /* c=1, 특정성: 001*/
  div.box {
  } /* b=1, c=1, 특정성: 011 */
  ```

```html
<div class="box area"></div>
```

```css
.box {
  color: red;
}
.area {
  color: blue;
} /* 뒤에 있는 area기 적용됨 */
```

## 상속

- 부모에 적용된 스타일이 자손 요소까지 영향을 주는 경우
- 다른 요소들에 특별히 CSS로 font-size를 지정하지 않으면, body의 font-size를 기본값으로 가져간다.
  - 컬러, 폰트, 타이포 같은 것들은 대부분 자손 요소에 영향을 준다.

```css
body {
  font-size: 18px;
  color: #333;
} /* 선호방법 */

/* input 같은 요소는 자체적인 스타일*/
/* inherit이라는 속성 값을 지정해서 명시적 상속 */
input,
button {
  font-size: inherit;
  color: inherit;
}
```

## 스타일 적용법과 각 적용법별 장단점

- 3가지 방법
  1. 특정한 요소에 `style` 속성을 이용해서 `style` 부여하기
  - 장점: 딱 해당 요소에만 스타일이 들어감, 특정성에서 높은 우선순위
  - 단점: 장점 외 모든 것 (확장성 저하)
  2. `style` 요소를 사용해서 해당 ㅁ페이지에 스타일을 주는 방법
  - 리액트 같은 모던 웹 애플리케이션 개발에서 많이 사용 (Styled Component)
  - 장점: 페이지별로 필요한 스타일만 지정해서 사용, 자바스크립트로 제어하기가 수월(CSSOM)
  - 단점: 공통 스타일을 관리하기에는 어려움, 페이지별로 들어가는 거다 보니 모든 페이지에 공용으로 쓰기 어렵다
  ```html
  <head>
    <style>
      .box {
      }
      .area {
      }
    </style>
  </head>
  ```
  3. 외부 파일로 `css` 파일을 만든다.
  - `<link>` 요소를 사용하여 해당 CSS를 연결
  - 장점: 공통으로 쓰이는 스타일을 관리하기 쉽다
  - 단점: 외부에 파일이 있기 때문에, HTTP 요성이 한 번 발생, CSS에 대한 이해도가 낮은 상태에서 공통 스타일을 만들면 꼬이기 매우 쉽다.

### 추가

- `:nth-of-type(even)` : 짝수만 적용
